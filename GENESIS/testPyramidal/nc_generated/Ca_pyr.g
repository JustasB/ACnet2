

// **************************************************
// File generated by: neuroConstruct v1.7.0 
// **************************************************

// This file holds the implementation in GENESIS of the Cell Mechanism:
// Ca_pyr (Type: Channel mechanism, Model: Template based ChannelML file)

// with parameters: 
// /channelml/@units = SI Units 
// /channelml/notes = ChannelML file containing a single Calcium Channel description, from the Hippocampal CA3 neuron model presented in Traub et al., 1991. 
// /channelml/channel_type/@name = Ca_pyr 
// /channelml/channel_type/@density = yes 
// /channelml/channel_type/status/@value = in_progress 
// /channelml/channel_type/status/comment = Transcribed from the Genesis implementation by David Beeman 
// /channelml/channel_type/status/contributor[1]/name = Padraig Gleeson 
// /channelml/channel_type/status/contributor[2]/name = Boris Marin 
// /channelml/channel_type/authorList/modelTranslator[1]/name = Padraig Gleeson 
// /channelml/channel_type/authorList/modelTranslator[1]/institution = UCL 
// /channelml/channel_type/authorList/modelTranslator[1]/email = p.gleeson - at - ucl.ac.uk 
// /channelml/channel_type/authorList/modelTranslator[2]/name = Boris Marin 
// /channelml/channel_type/authorList/modelTranslator[2]/institution = UCL 
// /channelml/channel_type/authorList/modelTranslator[2]/email = b.marin - at - ucl.ac.uk 
// /channelml/channel_type/publication/fullTitle = Traub, R. D., Wong, R. K., Miles, R., and Michelson, H. (1991). A model of a CA3 hippocampal pyramidal neuron incorporating voltage-clamp data on intr ... 
// /channelml/channel_type/publication/pubmedRef = http://www.ncbi.nlm.nih.gov/pubmed/1663538 
// /channelml/channel_type/neuronDBref/modelName = Ca channels 
// /channelml/channel_type/neuronDBref/uri = http://senselab.med.yale.edu/neurondb/NeuronProp.aspx?id=259&amp;mo=1&amp;re=&amp;pr=C 
// /channelml/channel_type/current_voltage_relation/@cond_law = ohmic 
// /channelml/channel_type/current_voltage_relation/@ion = ca 
// /channelml/channel_type/current_voltage_relation/@charge = 2 
// /channelml/channel_type/current_voltage_relation/@default_erev = 0.08 
// /channelml/channel_type/current_voltage_relation/@default_gmax = 1.328e-07 
// /channelml/channel_type/current_voltage_relation/gate[1]/@name = m 
// /channelml/channel_type/current_voltage_relation/gate[1]/@instances = 2 
// /channelml/channel_type/current_voltage_relation/gate[1]/closed_state/@id = m0 
// /channelml/channel_type/current_voltage_relation/gate[1]/open_state/@id = m 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[1]/@name = alpha 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[1]/@from = m0 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[1]/@to = m 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[1]/@expr_form = sigmoid 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[1]/@rate = 1.6e+03 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[1]/@scale = -1.389e-02 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[1]/@midpoint = 5e-03 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[2]/@name = beta 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[2]/@from = m 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[2]/@to = m0 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[2]/@expr_form = exp_linear 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[2]/@rate = 1e2 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[2]/@scale = -5e-3 
// /channelml/channel_type/current_voltage_relation/gate[1]/transition[2]/@midpoint = -8.9e-3 
// /channelml/channel_type/current_voltage_relation/gate[2]/@name = h 
// /channelml/channel_type/current_voltage_relation/gate[2]/@instances = 1 
// /channelml/channel_type/current_voltage_relation/gate[2]/closed_state/@id = h0 
// /channelml/channel_type/current_voltage_relation/gate[2]/open_state/@id = h 
// /channelml/channel_type/current_voltage_relation/gate[2]/time_course/@name = tau 
// /channelml/channel_type/current_voltage_relation/gate[2]/time_course/@from = hc 
// /channelml/channel_type/current_voltage_relation/gate[2]/time_course/@to = h 
// /channelml/channel_type/current_voltage_relation/gate[2]/time_course/@expr_form = generic 
// /channelml/channel_type/current_voltage_relation/gate[2]/time_course/@expr = 0.2 
// /channelml/channel_type/current_voltage_relation/gate[2]/steady_state/@name = inf 
// /channelml/channel_type/current_voltage_relation/gate[2]/steady_state/@from = hc 
// /channelml/channel_type/current_voltage_relation/gate[2]/steady_state/@to = h 
// /channelml/channel_type/current_voltage_relation/gate[2]/steady_state/@expr_form = generic 
// /channelml/channel_type/current_voltage_relation/gate[2]/steady_state/@expr = v &gt; -0.06 ? (exp (-50*(v + 0.06))) : 1 
// /channelml/channel_type/impl_prefs/table_settings/@max_v = 0.05 
// /channelml/channel_type/impl_prefs/table_settings/@min_v = -0.1 
// /channelml/channel_type/impl_prefs/table_settings/@table_divisions = 3000 

// File from which this was generated: /home/boris/git/ACnet2/neuroConstruct/cellMechanisms/Ca_pyr/Ca.xml

// XSL file with mapping to simulator: /home/boris/git/ACnet2/neuroConstruct/cellMechanisms/Ca_pyr/ChannelML_v1.8.1_GENESIStab.xsl



// This is a GENESIS script file generated from a ChannelML v1.8.1 file
// The ChannelML file is mapped onto a tabchannel object


// Units of ChannelML file: SI Units, units of GENESIS file generated: SI Units

/*
    ChannelML file containing a single Calcium Channel description, from the Hippocampal CA3 neuron model presented in Traub et al., 1991.
*/

function make_Ca_pyr

        str chanpath = "/library/Ca_pyr"

        if ({exists {chanpath}})
            return
        end
        
        create tabchannel {chanpath}
            

        setfield {chanpath} \ 
            Ek              0.08 \
            Ik              0  \
            Xpower          2 \
            Ypower          1
        
        setfield {chanpath} \
            Gbar 1.328e-07 \
            Gk              0 

        
        // No Q10 temperature adjustment found
        float temp_adj_m = 1
        float temp_adj_h = 1
    

        float tab_divs = 3000
        float v_min = -0.1

        float v_max = 0.05

        float v, dv, i
            
        // Creating table for gate m, using name X for it here

        float dv = ({v_max} - {v_min})/{tab_divs}
            
        call {chanpath} TABCREATE X {tab_divs} {v_min} {v_max}
                
        v = {v_min}

            

        for (i = 0; i <= ({tab_divs}); i = i + 1)
            
            // Looking at rate: alpha
                

            float alpha
                
            float A, B, Vhalf
                             

            // ChannelML form of equation: alpha which is of form sigmoid, with params:
            // A = 1.6e+03, B = -1.389e-02, Vhalf = 5e-03, in units: SI Units
            A = 1.6e+03
            B = -1.389e-02
            Vhalf = 5e-03
            alpha = A / ( {exp {(v - Vhalf) / B}} + 1)
        
            // Looking at rate: beta
                

            float beta
                
            float A, B, Vhalf
                             

            // ChannelML form of equation: beta which is of form exp_linear, with params:
            // A = 1e2, B = -5e-3, Vhalf = -8.9e-3, in units: SI Units
            A = 1e2
            B = -5e-3
            Vhalf = -8.9e-3
            

            if ( {abs {(v - Vhalf)/ B}} < 1e-6)
                beta = A * (1 + (v - Vhalf)/B/2)
            else
                beta = A * ((v - Vhalf) / B) /(1 - {exp {-1 * (v - Vhalf)/B}})
            end

        

            // Using the alpha and beta expressions to populate the tables

            float tau = 1/(temp_adj_m * (alpha + beta))
            
            setfield {chanpath} X_A->table[{i}] {temp_adj_m * alpha}
            setfield {chanpath} X_B->table[{i}] {temp_adj_m * (alpha + beta)}
                    
            v = v + dv

        end // end of for (i = 0; i <= ({tab_divs}); i = i + 1)
            
        setfield {chanpath} X_A->calc_mode 1 X_B->calc_mode 1
                    
        // Creating table for gate h, using name Y for it here

        float dv = ({v_max} - {v_min})/{tab_divs}
            
        call {chanpath} TABCREATE Y {tab_divs} {v_min} {v_max}
                
        v = {v_min}

            

        for (i = 0; i <= ({tab_divs}); i = i + 1)
            
            // Looking at rate: tau
                

            float tau
                
                        
            // Found a generic form of rate equation for tau, using expression: 0.2
            // Will translate this for GENESIS compatibility...
                    tau = 0.2
            
            // Looking at rate: inf
                

            float inf
                
                        
            // Found a generic form of rate equation for inf, using expression: v > -0.06 ? (exp (-50*(v + 0.06))) : 1
            // Will translate this for GENESIS compatibility...
                    

            if (v > -0.06 )
                inf =  {exp {-50*{v + 0.06}}} 
            else
                inf =  1
            end
        
            

            // Evaluating the tau and inf expressions

                    
            tau = tau/temp_adj_h
    

            
            // Working out the "real" alpha and beta expressions from the tau and inf
            
            float alpha
            float beta
            alpha = inf / tau   
            beta = (1- inf)/tau
            
            
            setfield {chanpath} Y_A->table[{i}] {alpha}
            setfield {chanpath} Y_B->table[{i}] {alpha + beta}

                
            v = v + dv

        end // end of for (i = 0; i <= ({tab_divs}); i = i + 1)
            
        setfield {chanpath} Y_A->calc_mode 1 Y_B->calc_mode 1
                    


end

